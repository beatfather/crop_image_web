{"ast":null,"code":"// This file includes code which was modified from https://github.com/openai/gpt-2\nconst fs = require('fs');\nconst path = require('path');\nconst encoder = JSON.parse(fs.readFileSync(path.join(__dirname, './encoder.json')));\nconst bpe_file = fs.readFileSync(path.join(__dirname, './vocab.bpe'), 'utf-8');\nconst range = (x, y) => {\n  const res = Array.from(Array(y).keys()).slice(x);\n  return res;\n};\nconst ord = x => {\n  return x.charCodeAt(0);\n};\nconst chr = x => {\n  return String.fromCharCode(x);\n};\nconst textEncoder = new TextEncoder(\"utf-8\");\nconst encodeStr = str => {\n  return Array.from(textEncoder.encode(str)).map(x => x.toString());\n};\nconst textDecoder = new TextDecoder(\"utf-8\");\nconst decodeStr = arr => {\n  return textDecoder.decode(new Uint8Array(arr));\n};\nconst dictZip = (x, y) => {\n  const result = {};\n  x.map((_, i) => {\n    result[x[i]] = y[i];\n  });\n  return result;\n};\nfunction bytes_to_unicode() {\n  const bs = range(ord('!'), ord('~') + 1).concat(range(ord('¡'), ord('¬') + 1), range(ord('®'), ord('ÿ') + 1));\n  let cs = bs.slice();\n  let n = 0;\n  for (let b = 0; b < 2 ** 8; b++) {\n    if (!bs.includes(b)) {\n      bs.push(b);\n      cs.push(2 ** 8 + n);\n      n = n + 1;\n    }\n  }\n  cs = cs.map(x => chr(x));\n  const result = {};\n  bs.map((_, i) => {\n    result[bs[i]] = cs[i];\n  });\n  return result;\n}\nfunction get_pairs(word) {\n  const pairs = new Set();\n  let prev_char = word[0];\n  for (let i = 1; i < word.length; i++) {\n    const char = word[i];\n    pairs.add([prev_char, char]);\n    prev_char = char;\n  }\n  return pairs;\n}\nconst pat = /'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu;\nconst decoder = {};\nObject.keys(encoder).map(x => {\n  decoder[encoder[x]] = x;\n});\nconst lines = bpe_file.split('\\n');\n\n// bpe_merges = [tuple(merge_str.split()) for merge_str in bpe_data.split(\"\\n\")[1:-1]]\nconst bpe_merges = lines.slice(1, lines.length - 1).map(x => {\n  return x.split(/(\\s+)/).filter(function (e) {\n    return e.trim().length > 0;\n  });\n});\nconst byte_encoder = bytes_to_unicode();\nconst byte_decoder = {};\nObject.keys(byte_encoder).map(x => {\n  byte_decoder[byte_encoder[x]] = x;\n});\nconst bpe_ranks = dictZip(bpe_merges, range(0, bpe_merges.length));\nconst cache = new Map();\nfunction bpe(token) {\n  if (cache.has(token)) {\n    return cache.get(token);\n  }\n  ``;\n  let word = token.split('');\n  let pairs = get_pairs(word);\n  if (!pairs) {\n    return token;\n  }\n  while (true) {\n    const minPairs = {};\n    Array.from(pairs).map(pair => {\n      const rank = bpe_ranks[pair];\n      minPairs[isNaN(rank) ? 10e10 : rank] = pair;\n    });\n    const bigram = minPairs[Math.min(...Object.keys(minPairs).map(x => {\n      return parseInt(x);\n    }))];\n    if (!(bigram in bpe_ranks)) {\n      break;\n    }\n    const first = bigram[0];\n    const second = bigram[1];\n    let new_word = [];\n    let i = 0;\n    while (i < word.length) {\n      const j = word.indexOf(first, i);\n      if (j === -1) {\n        new_word = new_word.concat(word.slice(i));\n        break;\n      }\n      new_word = new_word.concat(word.slice(i, j));\n      i = j;\n      if (word[i] === first && i < word.length - 1 && word[i + 1] === second) {\n        new_word.push(first + second);\n        i = i + 2;\n      } else {\n        new_word.push(word[i]);\n        i = i + 1;\n      }\n    }\n    word = new_word;\n    if (word.length === 1) {\n      break;\n    } else {\n      pairs = get_pairs(word);\n    }\n  }\n  word = word.join(' ');\n  cache.set(token, word);\n  return word;\n}\nfunction encode(text) {\n  let bpe_tokens = [];\n  const matches = Array.from(text.matchAll(pat)).map(x => x[0]);\n  for (let token of matches) {\n    token = encodeStr(token).map(x => {\n      return byte_encoder[x];\n    }).join('');\n    const new_tokens = bpe(token).split(' ').map(x => encoder[x]);\n    bpe_tokens = bpe_tokens.concat(new_tokens);\n  }\n  return bpe_tokens;\n}\nfunction decode(tokens) {\n  let text = tokens.map(x => decoder[x]).join('');\n  text = decodeStr(text.split('').map(x => byte_decoder[x]));\n  return text;\n}\nmodule.exports = {\n  encode,\n  decode\n};","map":{"version":3,"names":["fs","require","path","encoder","JSON","parse","readFileSync","join","__dirname","bpe_file","range","x","y","res","Array","from","keys","slice","ord","charCodeAt","chr","String","fromCharCode","textEncoder","TextEncoder","encodeStr","str","encode","map","toString","textDecoder","TextDecoder","decodeStr","arr","decode","Uint8Array","dictZip","result","_","i","bytes_to_unicode","bs","concat","cs","n","b","includes","push","get_pairs","word","pairs","Set","prev_char","length","char","add","pat","decoder","Object","lines","split","bpe_merges","filter","e","trim","byte_encoder","byte_decoder","bpe_ranks","cache","Map","bpe","token","has","get","minPairs","pair","rank","isNaN","bigram","Math","min","parseInt","first","second","new_word","j","indexOf","set","text","bpe_tokens","matches","matchAll","new_tokens","tokens","module","exports"],"sources":["C:/Users/94272/Desktop/Job/my-personal_website/beattather/node_modules/gpt-3-encoder/Encoder.js"],"sourcesContent":["// This file includes code which was modified from https://github.com/openai/gpt-2\nconst fs = require('fs')\nconst path = require('path');\n\nconst encoder = JSON.parse(fs.readFileSync(path.join(__dirname, './encoder.json')));\nconst bpe_file = fs.readFileSync(path.join(__dirname, './vocab.bpe'), 'utf-8');\n\nconst range = (x, y) => {\n  const res = Array.from(Array(y).keys()).slice(x)\n  return res\n}\n\nconst ord = x => {\n  return x.charCodeAt(0)\n}\n\nconst chr = x => {\n  return String.fromCharCode(x)\n}\n\nconst textEncoder = new TextEncoder(\"utf-8\")\nconst encodeStr = str => {\n  return Array.from(textEncoder.encode(str)).map(x => x.toString())\n}\n\nconst textDecoder = new TextDecoder(\"utf-8\")\nconst decodeStr = arr => {\n  return textDecoder.decode(new Uint8Array(arr));\n}\n\nconst dictZip = (x, y) => {\n  const result = {}\n  x.map((_, i) => { result[x[i]] = y[i] })\n  return result\n}\n\nfunction bytes_to_unicode() {\n  const bs = range(ord('!'), ord('~') + 1).concat(range(ord('¡'), ord('¬') + 1), range(ord('®'), ord('ÿ') + 1))\n\n  let cs = bs.slice()\n  let n = 0\n  for (let b = 0; b < 2 ** 8; b++) {\n    if (!bs.includes(b)) {\n      bs.push(b)\n      cs.push(2 ** 8 + n)\n      n = n + 1\n    }\n  }\n\n  cs = cs.map(x => chr(x))\n\n  const result = {}\n  bs.map((_, i) => { result[bs[i]] = cs[i] })\n  return result\n}\n\nfunction get_pairs(word) {\n  const pairs = new Set()\n  let prev_char = word[0]\n  for (let i = 1; i < word.length; i++) {\n    const char = word[i]\n    pairs.add([prev_char, char])\n    prev_char = char\n  }\n  return pairs\n}\n\nconst pat = /'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+/gu\n\nconst decoder = {}\nObject.keys(encoder).map(x => { decoder[encoder[x]] = x })\n\nconst lines = bpe_file.split('\\n')\n\n// bpe_merges = [tuple(merge_str.split()) for merge_str in bpe_data.split(\"\\n\")[1:-1]]\nconst bpe_merges = lines.slice(1, lines.length - 1).map(x => {\n  return x.split(/(\\s+)/).filter(function(e) { return e.trim().length > 0 })\n})\n\nconst byte_encoder = bytes_to_unicode()\nconst byte_decoder = {}\nObject.keys(byte_encoder).map(x => { byte_decoder[byte_encoder[x]] = x })\n\nconst bpe_ranks = dictZip(bpe_merges, range(0, bpe_merges.length))\nconst cache = new Map;\n\nfunction bpe(token) {\n  if (cache.has(token)) {\n    return cache.get(token)\n  }``\n\n  let word = token.split('')\n\n  let pairs = get_pairs(word)\n\n  if (!pairs) {\n    return token\n  }\n\n  while (true) {\n    const minPairs = {}\n    Array.from(pairs).map(pair => {\n      const rank = bpe_ranks[pair]\n      minPairs[(isNaN(rank) ? 10e10 : rank)] = pair\n    })\n\n\n\n    const bigram = minPairs[Math.min(...Object.keys(minPairs).map(x => {\n      return parseInt(x)\n    }\n    ))]\n\n    if (!(bigram in bpe_ranks)) {\n      break\n    }\n\n    const first = bigram[0]\n    const second = bigram[1]\n    let new_word = []\n    let i = 0\n\n    while (i < word.length) {\n      const j = word.indexOf(first, i)\n      if (j === -1) {\n        new_word = new_word.concat(word.slice(i))\n        break\n      }\n      new_word = new_word.concat(word.slice(i, j))\n      i = j\n\n      if (word[i] === first && i < word.length - 1 && word[i + 1] === second) {\n        new_word.push(first + second)\n        i = i + 2\n      } else {\n        new_word.push(word[i])\n        i = i + 1\n      }\n    }\n\n    word = new_word\n    if (word.length === 1) {\n      break\n    } else {\n      pairs = get_pairs(word)\n    }\n  }\n\n  word = word.join(' ')\n  cache.set(token, word)\n\n  return word\n}\n\nfunction encode(text) {\n  let bpe_tokens = []\n  const matches = Array.from(text.matchAll(pat)).map(x => x[0])\n  for (let token of matches) {\n    token = encodeStr(token).map(x => {\n      return byte_encoder[x]\n    }).join('')\n    \n    const new_tokens = bpe(token).split(' ').map(x => encoder[x])\n    bpe_tokens = bpe_tokens.concat(new_tokens)\n  }\n  return bpe_tokens\n}\n\nfunction decode(tokens) {\n  let text = tokens.map(x => decoder[x]).join('')\n  text = decodeStr(text.split('').map(x => byte_decoder[x]))\n  return text\n}\n\nmodule.exports = {\n  encode,\n  decode\n};"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}